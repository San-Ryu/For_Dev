<문제 풀이>
■ 최빈수
	Counting 정렬 - 양의 정수에 대한 
	
	정수 정보를 따로 저장할 필요는 없음.
	범위 내의 숫자에 대하여, 범위 내 인덱스 설정 (1부터 100까지면 1 ~ 100까지의 배열을 만듦)
	int cnt[] = new int[100];

■ Flatten
	높이 정보가 쭉 주어짐.
	
	입력 받고나서, 
	
	최대값을 찾고, 최소값을 찾는 것을 덤프의 수만큼 반복하면 됨.

■ 수확하기

■ 스도쿠

<이론>
■ 그래프
0) 개요
	- 개체간의 관계를 표현
	- 실세계의 현상을 추상화
	- 정점 (V), 간선 (E)

1) 방향성
	- 무향 그래프  (양방향 간선)
		동등한 관계
	- 유향 그래프 (단방향 간선)
		대소관계, 종속관계, 지도 상 위치 및 목적지 등
		DAG (Directed Acyclic Graph) 사이클이 없는 유향 그래프

2) 가중치 그래프 
	거리, 비용 등

4) 인접
	u -> v일 시, u와 v는 인접.

5) 그래프의 정보 저장
	- 인접 행렬
		정점의 개수가 500개 이상이라면, 고민해봐야 함.
		(인접행렬로 하면 효율성이 떨어질 수 있음)

		v x v 크기의 행렬이 필요.
		
		무향 그래프
		하나의 간선 정보로 양쪽에 표시해야 함.
		-> 10개의 간선정보 - 20개의 표시가 필요. 대각선 기준 위 10 아래 10 등
		
		유향 그래프
		하나의 간선에 한번만 표시
	 - 인접 리스트
		필요한 정점만 저장
	 - 간선 리스트
		
6) 실행시간
	실행시간은 정점과 간선에 의존적이다.

■ 그래프 탐색
http://www.algocoding.net/graph/shortest_path/brute_force.html

0) 개요
	비선형 자료구조
	
1) DFS
	
2) 컴포넌트
	모든 정점을 방문할 때까지 반복되는 DFS

3) BFS
	- 간선의 가중치가 부여되지 않은 경우, BFS를 통해 최단경로 판단 가능.

		D - 시작점으로부터의 거리 (Degree)
		P - 최단경로 트리 (어딜 거쳐서 왔는지)
			
			1	2	3	4	5	6	7	8
		D	0	1	1	2	2	2	3	3
		P	1	1	1	2	2	3	4	6
		
		Q 1(x) 2(x) 3(x) 4(x) 5(x) 6(x) 7 8
		8에 도달하는 시점에서(탐색이 완료되는 시점에서) 함수 종료되어 7, 8은 Poll되지 않음.
	
	- 간선의 가중치가 부여되어있는 경우, BFS로 최단경로를 구하려 할 때의 제한점
		1 2 (5)
		1 3	(1)
		2 6 (6)
		3 4 (2)
		4 5 (1)
		5 6 (2)
		6 7 (3)
		
		방문 중복 처리로 인해 짧은 경로임에도 방문이 안되는 경우가 있을 수 있음.
		다익스트라 알고리즘과는 달리 가중치가 중요하다. (경로가 중요한 것이 아니다.)
		(특히, 거리는 짧음에도 정점이 많은 경우)
		
		-> 정점 Queue와는 별도로 가중치 Queue를 만들어서 제어해주면 좋음.
		
		간선 완화 개념
		
	- 탐욕적 선택 / 최적 부분 구조
		탐욕적 선택 : 최적 부분 구조 + 탐욕적 선택 과정 
	
	- Brute-Force
		인접 리스트 등을 통한 가지기가 되지 않으면, 일반 BFS랑 다를 바가 없다.
	
	- 결합 컴포넌트
		그래프의 정점들은 결합 컴포넌트들(Connected Components)로 분리 가능
		정점 V가 정점 W에서 도달 가능하면, 두 정점은 동이한 결합 컴포넌트 내에 존재
	
	- 위상 정렬, 다익스트라 알고리즘, 최소 신장
		
		
		
		
		