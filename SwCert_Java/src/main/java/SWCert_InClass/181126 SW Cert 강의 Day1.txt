 * 삼성전자는 라이브러리 호출 불가 (AD부터)

■ 비트 연산
■ 재귀호출
■ 배열
■ 그래프
■ 트리
■ 완전 탐색
■ 백트래킹
■ 라이브러리

알고리즘 설계 기법
완전 탐색 -> 백트래킹, 동적 계획법

완전 탐색 = 최적화 문제

알고리즘이 정확한가?
알고리즘이 효율적인가?

■ 문제 유형
Desicion Problems
Optimization Problems
Counting / Searching Problems

유형 1. 결정문제
		입력 -> 그래프, 정점과 간선
		출력 -> S to T 경로 존재 여부
유형 2. 최적화 문제 (최적해를 찾는 문제)
		출력 -> S to T 최단 경로 거리
		- 가능한 모든 후보해를 조사해야함.
		- 순열(n!), 부분집합(2^n), 조합
		- 문제의 조건을 만족하는 값이 최대 혹은 최소가 되는 경우
		- 백트래킹 -> (상태공간트리 탐색 + 가지치기)
		  동적계획법 -> (문제간의 관계 + 메모이제이션)
		  탐욕기법 -> 완전 탐색을 하지 않고도 답을 구하는 경우.
		            (모든 경우에 대해 최적해를 찾기 어려우므로, 최적해 문제에서는 하지 말자.)
유형 3. 경우의 문제
		출력 -> S to T 경로의 경우의 수
유형 4. 탐색의 문제
		출력 -> S to T 경로
		
https://swexpertacademy.com/main/main.do


■ 비트 연산자
비트 연산자가 CPU를 가장 적게 잡아먹음 (속도가 빠름)
나누기/나머지가 CPU를 가장 많이 잡아먹음.

- Not ~ 
	1) Unary Bitwise Complement
	2) 토글링 (0 -> 1, 1 -> 0)
- And &
- Or |
- Exclusive Or ^

- Shift 연산
	1) Signed Left Shift  >>
	2) Signed Right Shift  <<
	
	3) 최하위비트가 1인지만 보면, 짝수/홀수를 판별할 수 있다.
	
	4) 특정 위치의 비트 값이 1일지 아닌지 확인하기
		Ex) 0x34 & (1 << 4)인 경우, 
			2^4 = 1이면 2^4가 나오고, 아니면 0이 나온다.
	5) 특정 위치의 비트값을 0으로 설정하기
		
	6) 특정 위치의 비트값 토글링 (0 -> 1, 1 -> 0)
	
	7) 부분집합 표현 및 집합 연산자
	   그래프에서 정점의 개수가 얼마 되지 않으면 표현 가능
		
	8) 바이너리 카운팅
		
■ 배열

■ 재귀
 - 문제를 재귀적으로 정의하는 전체적인 것을 말함. (DFS나 백트래킹 등에 국한되지 않음.)
 - 이진 트리 순회(후보해를 찾기 위해 트리의 끝(단말 노드)까지 가야함.)
   DFS
   (깊이 우선 탐색)
   백트래킹
 - 분할 정복 
   (애초에 같은 문제를 풀지 않기 때문에, 메모이제이션을 적용하지 않음.)
 - 자기 자신을 다시 호출하는 재귀 함수로 구현
 - 재귀호출을 하다가 어느 시점에서는 끊어야한다. (계속 끊임없이 가면, StackOverFlow...)
   종료조건(기저 사례)을 지정해줘야함.
 - 정렬
   1) Array : array.sort
   2) ArrayList : collections.sort
   
 
 