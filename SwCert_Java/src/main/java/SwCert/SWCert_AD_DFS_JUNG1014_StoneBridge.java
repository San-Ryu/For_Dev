package SwCert;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/*
[JUNG1014]돌다리 건너기

[문제] 
절대반지를 얻기 위하여 반지원정대가 출발한다. 원정대가 지나가야할 다리는 두 개의 인접한 돌다리로 구성되어 있다. 하나는 <악마의 돌다리>이고 다른 하나는 <천사의 돌다리>이다.
아래 그림 1은 길이가 6인 다리의 한 가지 모습을 보여준다. 그림에서 위의 가로줄은 <악마의 돌다리>를 표시하는 것이고, 아래의 가로줄은 <천사의 돌다리>를 표시한다. 두 돌다리의 길이는 항상 동일하며, 각 칸의 문자는 해당 돌에 새겨진 문자를 나타낸다. 두 다리에 새겨진 각 문자는 {R, I, N, G, S} 중 하나이다.
반지원정대가 소유하고 있는 마법의 두루마리에 <악마의 돌다리>와 <천사의 돌다리>를 건너갈 때 반드시 순서대로 밟고 지나가야할 문자들이 적혀있다. 이 순서대로 지나가지 않으면 돌다리는 무너져 반지원정대는 화산 속으로 떨어지게 된다.
다리를 건널 때 다음의 제한 조건을 모두 만족하면서 건어야 한다.
1) 왼쪽(출발지역)에서 오른쪽(도착지역)으로 다리를 지나가야 하며, 반드시 마법의 두루마리에 적힌 문자열의 순서대로 모두 밟고 지나가야 한다.
2) 반드시 <악마의 돌다리>와 <천사의 돌다리>를 번갈아가면서 돌을 밟아야 한다. 단, 출발은 어떤 돌다리에서 시작해도 된다.
3) 반드시 한 칸 이상 오른쪽으로 전진해야하며, 건너뛰는 칸의 수에는 상관이 없다. 만일 돌다리의 모양이 그림 1고 같고 두루마리의 문자열이 "RGS"라면 돌다리를 건너갈 수 있는 경우는 다음의 3가지 뿐이다. (아래 그림에서 빨간색 문자는 밟고 지나가는 돌다리를 나타낸다.)
아래의 세 방법은 실패한 방법이다.
왜냐하면 첫 번째는 문자열 "RGS"를 모두 밟고 지나가야 하는 조건 1)을 만족하지 않으며, 두 번째는 번갈아가면서 돌을 밟아야 하는 조건 2)를, 세 번째는 앞으로 전진을 하여야하는 조건 3)을 만족하지 않기 때문이다.
마법의 두루마리에 적힌 문자열과 두 다리의 돌에 새겨진 문자열이 주어졌을 때, 돌다리를 통과할 수 있는 모든 가능한 방법의 수를 계산하는 프로그램을 작성하시오. 예를 들어, 그림 1의 경우는 통과하는 방법이 3가지가 있으므로 3을 출력해야 한다.

[입력]
첫째 줄에는 마법의 두루마리에 적힌 문자열(R, I, N, G, S 로만 구성된)이 주어진다. 
이 문자열의 길이는 최소 1, 최대 10 이다. 
그 다음 줄에는 각각 <악마의 돌다리>와 <천사의 돌다리>를 나타내는 같은 길이의 문자열이 주어진다. 
그 길이는 5 이상, 30 이하이다.

[출력]
출력 파일에 마법의 두루마리에 적힌 문자열의 순서대로 다리를 건너갈 수 있는 방법의 수를 출력한다.
그러한 방법이 없으면 0을 출력한다.
모든 테스트 데이터에 대한 출력결과는 231-1 이하이다.
*/
/* DFS 함수 설계 비법

0) Main 생성
  DFS(0,2,0);
 
1) 파라미터
   pos -> [밟을 다리 위치] 사용할 숫자의 위치(index)
   ab -> [pos 이전에 밟은 위치] 0(a밟음),1(b밟음),2(안밟음)
   tpos -> [밟을 문자의 위치]

2) 리턴 값
   [ void 사용 ] 모든 경우의 수 확인후 방법 가지수 누적
     
3) 종료 조건   
     if(tpos == t.length) 밟은 문자위치가 끝까지 왔으면,
     if(pos == ab.length) 마지막까지 왔으면,
         sol++ 방법수 누적

4) 가지치기
      1) 이전 ab랑 같으면,
      2) 문자가 다르면,
     *3) 남은 돌다리가 남은 문자보다 작으면,
*/
public class SWCert_AD_DFS_JUNG1014_StoneBridge {
//사이트 제출 시에는 반드시 Class명을 Main으로 지정해야함
//public class Main{
	// 마법의 두루마리 배열
	static char[] t;
	
	// 악마의 돌다리 배열
	static char[] a;
	
	// 천사의 돌다리 배열
	static char[] b;

    static int T_len;

    static int AB_len;
	
	static int sol;
	
    // pos: 돌다리의 위치
    // ab: 이번에 밟아야하는 돌다리의 위치
    // tpos: 일치하는 문자열의 수
	static void DFS(int pos, int ab, int tpos){

        // 종료조건
        if(tpos == T_len) {
              sol++;
              return;
        }
        // 종료조건
        if(pos == AB_len) return;        
        
			// 이전 밟은것이 0이 아니면서 문자열이 같으면
		    if(ab != 0 && a[pos] == t[tpos]){
		    	// 경우의 수는 독립적으로 수행됨
		    	// A를 밟은 경우
		    	DFS(pos+1, 0, tpos+1);
		    }
			
		    if(ab != 1 && b[pos] == t[tpos]){
		    	// B를 밟은 경우
		    	DFS(pos+1, 1, tpos+1);
		    }
			
			// 밟지 않는 경우
			DFS(pos+1, ab, tpos);
			
		
	}
	
	public static void main(String[] args) throws FileNotFoundException{

   	    System.setIn(new FileInputStream("test24.txt")); 
        Scanner sc = new Scanner(System.in);

        t = (sc.next()+"\0").toCharArray();
        a = (sc.next()+"\0").toCharArray();
        b = (sc.next()+"\0").toCharArray();

        for(int i=0; ; i++) {
            if(t[i] == 0) break;
            T_len++;
      }

      for(int i=0; ; i++) {
            if(a[i] == 0) break;
            AB_len++;
      }
		
		DFS(0,0,0); // A를 밝은것 처럼
		DFS(0,1,0); // B를 밟은것 처럼
		
		System.out.println(sol);

	}	
}